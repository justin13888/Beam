use std::collections::HashMap;
use std::path::Path;
use std::sync::Arc;
use tokio::sync::Mutex;
use tracing::{info, trace};

use crate::services::hash::HashService;
use crate::services::media_info::MediaInfoService;
use crate::utils::{
    file::FileType,
    stream::{StreamBuilder, mp4::MP4StreamGenerator},
};

/// Abstracts the MP4 generation step so it can be replaced in tests.
#[async_trait::async_trait]
pub trait Mp4Generator: Send + Sync + std::fmt::Debug {
    async fn generate_mp4(
        &self,
        source_path: &Path,
        output_path: &Path,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;
}

/// Production implementation: uses ffmpeg_next via StreamBuilder + MP4StreamGenerator.
#[derive(Debug, Clone)]
pub struct LocalMp4Generator {
    hash_service: Arc<dyn HashService>,
    media_info_service: Arc<dyn MediaInfoService>,
}

impl LocalMp4Generator {
    pub fn new(
        hash_service: Arc<dyn HashService>,
        media_info_service: Arc<dyn MediaInfoService>,
    ) -> Self {
        Self {
            hash_service,
            media_info_service,
        }
    }
}

#[async_trait::async_trait]
impl Mp4Generator for LocalMp4Generator {
    async fn generate_mp4(
        &self,
        source_path: &Path,
        output_path: &Path,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        ffmpeg_next::init()?;

        let mut stream_builder =
            StreamBuilder::new(self.hash_service.clone(), self.media_info_service.clone());
        stream_builder.add_file(FileType::Video, source_path);
        let stream_configuration = stream_builder.build().await?;

        let mp4_generator = MP4StreamGenerator::from(stream_configuration);
        mp4_generator.generate_mp4(output_path).await?;

        Ok(())
    }
}

#[async_trait::async_trait]
pub trait TranscodeService: Send + Sync + std::fmt::Debug {
    /// Generate MP4 cache file from source video
    async fn generate_mp4_cache(
        &self,
        source_path: &Path,
        output_path: &Path,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;
}

#[derive(Debug, Clone)]
pub struct LocalTranscodeService {
    mp4_generator: Arc<dyn Mp4Generator>,
    // Distributed locks would be better, but local map works for single instance
    locks: Arc<Mutex<HashMap<String, Arc<Mutex<()>>>>>,
}

impl LocalTranscodeService {
    pub fn new(mp4_generator: Arc<dyn Mp4Generator>) -> Self {
        Self {
            mp4_generator,
            locks: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

#[async_trait::async_trait]
impl TranscodeService for LocalTranscodeService {
    /// Generate MP4 cache file from source video
    // TODO: Instrument this and log the average time taken, separated by the various hot paths (e.g. cache miss and cache hit)
    async fn generate_mp4_cache(
        &self,
        source_path: &Path,
        output_path: &Path,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let cache_key = output_path.to_string_lossy().to_string();

        // Get or create a lock for this specific cache file
        let lock = {
            let mut locks_map = self.locks.lock().await;
            locks_map
                .entry(cache_key.clone())
                .or_insert_with(|| Arc::new(Mutex::new(())))
                .clone()
        };

        // Acquire the lock - only one task can generate this file at a time
        let _guard = lock.lock().await;

        // Check again if file exists (another task might have created it while we waited)
        if output_path.exists() {
            trace!("MP4 already generated by another task: {:?}", output_path);
            return Ok(());
        }

        trace!("Starting MP4 generation in background task...");

        self.mp4_generator
            .generate_mp4(source_path, output_path)
            .await?;

        info!("MP4 generation completed successfully");
        Ok(())
    }
}

#[cfg(test)]
#[path = "transcode_tests.rs"]
mod transcode_tests;
